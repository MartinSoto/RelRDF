import sys
import pprint

import antlr

import error
from expression import nodes
from expression import rewrite


class LocationNode(nodes.ExpressionNode):
    """An expression node with location information."""

    __slots__ = ('line',
                 'column',
                 'fileName')

    def __init__(self, line=None, column=None, fileName=None):
        super(LocationNode, self).__init__()

        self.line = line
        self.column = column
        self.fileName = fileName


class QName(LocationNode):
    """An expression node representing a qualified name."""

    __slots__ = ('qname')

    def __init__(self, qname, line=None, column=None, fileName=None):
        super(QName, self).__init__(line, column, fileName)

        self.qname = qname 

    def prettyPrintAttributes(self, stream, indentLevel):
        stream.write(' %s' % self.qname)
        

class Var(LocationNode):
    """An expression node representing a SerQL variable by name."""

    __slots = ('name')

    def __init__(self, name, line=None, column=None, fileName=None):
        super(Var, self).__init__(line, column, fileName)

        self.name = name

    def prettyPrintAttributes(self, stream, indentLevel):
        stream.write(' %s' % self.name)


class SelectContext(object):
    """A container for contextual information associated to a single
    SerQL SELECT statement."""

    __slots__ = ('incarnations',
                 'bindings',
                 'indepMapping')

    def __init__(self):
        self.incarnations = {}
        self.bindings = {}
        self.indepMapping = {}

    def getIndependent(self):
        return frozenset(self.indepMapping.values())

    independent = property(getIndependent)

    def addBinding(self, varName, relName, incarnation, columnId):
        try:
            varBindings = self.bindings[varName]
        except KeyError:
            varBindings = set()
            self.bindings[varName] = varBindings

        varBindings.add(nodes.FieldRef(relName, incarnation, columnId))

    def addIndependentPair(self, var1, var2):
        if var1.name == var2.name:
            return

        group1 = self.indepMapping.get(var1.name)
        group2 = self.indepMapping.get(var2.name)

        if not group1 and not group2:
            group = frozenset((var1, var2))
        elif group1 and not group2:
            group = group1
        elif not group1 and group2:
            group = group2
        else:
            # Merge both groups.
            group = group1.union(group2)
            for var in group:
                self.indepMapping[var.name] = group

        self.indepMapping[var1.name] = group
        self.indepMapping[var2.name] = group

    def getIncarnation(self, relName):
        incarnation = self.incarnations.get(relName, 0) + 1
        self.incarnations[relName] = incarnation
        return incarnation

    def getCondition(self):
        subconds = []

        for binding in self.bindings.values():
            if len(binding) >= 2:
                subconds.append(nodes.Equal(*binding))

        for group in self.independent:
            refs = []
            for var in group:
                refs.append(iter(self.bindings[var.name]).next())
            if len(group) >= 2:
                subconds.append(nodes.Different(*refs))

        if len(subconds) == 0:
            return None
        elif len(subconds) == 1:
            return subconds[0]
        else:
            return nodes.And(*subconds)

    def expandVariables(self, expr):
        def operation(expr, subexprsModif, *subexprs):
            assert isinstance(expr, Var)
            assert subexprsModif == False

            # Select an arbitrary binding.
            try:
                return iter(self.bindings[expr.name]).next(), True
            except KeyError:
                raise error.SemanticError(
                    msg=_("Unbound variable '%s'") % expr.name,
                    line=expr.line, column=expr.column,
                    fileName=expr.fileName)

        return rewrite.treeMatchApply(Var, operation, expr)[0]

    def prettyPrint(self, stream=None, indent=0):
        if stream == None:
            stream = sys.stdout

        stream.write('Incarnations:\n')
        pprint.pprint(self.incarnations, stream, indent + 2)
        stream.write('\nBindings:\n')
        pprint.pprint(self.bindings, stream, indent + 2)
        stream.write('\nIndependent groups:\n')
        pprint.pprint(self.independent, stream, indent + 2)


class Parser(antlr.LLkParser):
    """The base class for the SerQL parser generated by ANTLR."""

    __slots__ = ('contextStack',

                 'externalPrefixes',
                 'localPrefixes')

    # The standard SerQL predefined prefixes.
    basePrefixes = {
        'rdf': 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
        'rdfs': 'http://www.w3.org/2000/01/rdf-schema#',
        'xsd': 'http://www.w3.org/2001/XMLSchema#',
        'owl': 'http://www.w3.org/2002/07/owl#',
        'serql': 'http://www.openrdf.org/schema/serql#'}


    def __init__(self, *args, **kwargs):
        """Initializes a Parser object.

        If a keyword argument 'prefixes' is provided, it will be
        expected to be a dictionary containing predefined namespace
        prefix bindings intended to be used in addition to the
        standard SerQL prefixes. See `Parser.getPrefixUri` for
        details."""
        super(Parser, self).__init__(*args, **kwargs)

        # A stack of SelectContext objects, to handle nested SELECT
        # queries.
        self.contextStack = []

        try:
            self.externalPrefixes = kwargs['prefixes']
        except KeyError:
            self.externalPrefixes = {}

        # The set of locally defined namespace prefixes (prefixes
        # defined by the query itself through the USING NAMESPACE
        # clause.)
        self.localPrefixes = {}

    def pushContext(self):
        """Push a new select context into the context stack."""
        self.contextStack.append(SelectContext())

    def popContext(self):
        """Pop the topmost context form the context stack and return
        it."""
        return self.contextStack.pop()

    def currentContext(self):
        """Return the current (topmost) context."""
        return self.contextStack[-1]

    def createLocalPrefix(self, prefix, uri):
        """Create a new local prefix `prefix` with associated URI
        `uri`."""
        self.localPrefixes[prefix] = uri

    def getPrefixUri(self, prefix):
        """Return the URI associated to namespace prefix `prefix`.

        Prefixes will be searched for first in the locally defined
        set, then in the external set provided when constructing the
        parser object, and finally in the predefined SerQL base set.

        A `KeyError` will be raised if the given prefix is not found."""
        try:
            return self.localPrefixes[prefix]
        except KeyError:
            try:
                return self.externalPrefixes[prefix]
            except KeyError:
                return self.basePrefixes[prefix]


    #
    # Expression Construction and Transformation
    #

    def exprFromTriple(self, subject, pred, object):
        incarnation = self.currentContext().getIncarnation('S')

        conds = []
        for id, node in (('subject', subject), ('predicate', pred),
                         ('object', object)):
            if isinstance(node, Var):
                self.currentContext().addBinding(node.name, 'S',
                                                 incarnation, id)
            else:
                ref = nodes.FieldRef('S', incarnation, id)
                conds.append(nodes.Equal(ref, node))

        rel = nodes.Relation('S', incarnation)
        if conds == []:
            return rel
        else:
            return nodes.Select(rel, nodes.And(*conds))

    def exprFromPattern(self, nodeList1, edge, nodeList2):
        rels = []

        indepVar1 = None
        indepVar2 = None

        for node1 in nodeList1:
            for node2 in nodeList2:
                rels.append(self.exprFromTriple(node1, edge, node2))

                if isinstance(node1, Var):
                    if indepVar1:
                        self.currentContext() \
                            .addIndependentPair(indepVar1, node1)
                    else:
                        indepVar1 = node1

                if isinstance(node2, Var):
                    if indepVar2:
                        self.currentContext() \
                            .addIndependentPair(indepVar2, node2)
                    else:
                        indepVar2 = node2

        if len(rels) > 1:
            return nodes.Product(*rels)
        else:
            return rels[0]

    def graphPatternExpr(self, node):
        cond = self.currentContext().getCondition()
        if cond:
            node = nodes.Select(node, cond)
        return node

    def selectQueryExpr(self, (columnNames, mappingExprs), baseExpr,
                        condExpr):
        current = baseExpr
        if condExpr:
            current = nodes.Select(current, self.currentContext(). \
                                   expandVariables(condExpr))
        current = nodes.MapResult(columnNames, current,
                                  *[self.currentContext(). \
                                    expandVariables(mappingExpr)
                                    for mappingExpr in mappingExprs])
        return current

    def resolveQName(self, qName):
        """Create a URI expression node corresponding to qualified
        name `qName`."""
        pos = qName.index(':')
        base = self.getPrefixUri(qName[:pos])
        return nodes.Uri(base + qName[pos + 1:])

    def expandQNames(self, expr):
        """Expand all QName nodes in `expr` into their corresponding
        URIs."""

        def operation(expr, subexprsModif, *subexprs):
            assert isinstance(expr, QName)
            assert subexprsModif == False

            try:
                return self.resolveQName(expr.qname), True
            except KeyError:
                raise error.SemanticError(
                    msg=_("Undefined namespace prefix '%s'") % expr.qname,
                    line=expr.line, column=expr.column,
                    fileName=expr.fileName)

        return rewrite.treeMatchApply(QName, operation, expr)[0]

    def checkPrefix(self, token):
        if token.getText() == '_':
            raise error.SyntaxError(msg=_("Invalid namespace prefix '_'"),
                                    line=token.getLine(),
                                    column=token.getColumn(),
                                    fileName=self.getFilename())
        return token.getText()
